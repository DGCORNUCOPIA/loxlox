// Lox interpreter written in ... Lox!

// TODO decimal handling
// also: test/number/trailing_dot.lox
// also: test/number/decimal_point_at_eof.lox

// TODO: string unicode - probably due to Java getc
// test/string/literals.lox

// Scanner: converts Lox source code input into tokens

// One-character tokens (values are the ASCII codes)
var LEFT_PAREN = 40;
var RIGHT_PAREN = 41;
var LEFT_BRACE = 123;
var RIGHT_BRACE = 125;
var COMMA = 44;
var DOT = 46;
var MINUS = 45;
var PLUS = 43;
var SEMICOLON = 59;
var SLASH = 47;
var STAR = 42;
var BANG = 33;
var EQUAL = 61;
var GREATER = 62;
var LESS = 60;

// Two-character tokens
var BANG_EQUAL = 256;
var EQUAL_EQUAL = 257;
var GREATER_EQUAL = 258;
var LESS_EQUAL = 259;

// Literals
var IDENTIFIER = 260;
var STRING = 261;
var NUMBER = 262;

// Keywords
var AND = 263;
var CLASS = 264;
var ELSE = 265;
var FALSE = 266;
var FUN = 267;
var FOR = 268;
var IF = 269;
var NIL = 270;
var OR = 271;
var PRINT = 272;
var RETURN = 273;
var SUPER = 274;
var THIS = 275;
var TRUE = 276;
var VAR = 277;
var WHILE = 278;

// Misc tokens
var EOF = 279;
var INVALID = 280;

class Token {
  init(type, value, line) {
    this.type = type;
    this.value = value;
    this.line = line;
  }
}

fun tokenTypeStr(type) {
  if (type == LEFT_PAREN) return "(";
  if (type == RIGHT_PAREN) return ")";
  if (type == LEFT_BRACE) return "{";
  if (type == RIGHT_BRACE) return "}";
  if (type == COMMA) return ",";
  if (type == DOT) return ".";
  if (type == MINUS) return "-";
  if (type == PLUS) return "+";
  if (type == SEMICOLON) return ";";
  if (type == SLASH) return "/";
  if (type == STAR) return "*";
  if (type == BANG) return "!";
  if (type == EQUAL) return "=";
  if (type == GREATER) return ">";
  if (type == LESS) return "<";

  if (type == BANG_EQUAL) return "!=";
  if (type == EQUAL_EQUAL) return "==";
  if (type == GREATER_EQUAL) return ">=";
  if (type == LESS_EQUAL) return "<=";

  if (type == IDENTIFIER) return "<identifier>";
  if (type == STRING) return "<string>";
  if (type == NUMBER) return "<number>";

  if (type == AND) return "and";
  if (type == CLASS) return "class";
  if (type == ELSE) return "else";
  if (type == FALSE) return "false";
  if (type == FUN) return "fun";
  if (type == FOR) return "for";
  if (type == IF) return "if";
  if (type == NIL) return "nil";
  if (type == OR) return "or";
  if (type == PRINT) return "print";
  if (type == RETURN) return "return";
  if (type == SUPER) return "super";
  if (type == THIS) return "this";
  if (type == TRUE) return "true";
  if (type == VAR) return "var";
  if (type == WHILE) return "while";

  if (type == EOF) return "<eof>";
  if (type == INVALID) return "<invalid>";

  return nil;
}

fun keywordType(name) {
  if (name == "and") return AND;
  if (name == "class") return CLASS;
  if (name == "else") return ELSE;
  if (name == "false") return FALSE;
  if (name == "fun") return FUN;
  if (name == "for") return FOR;
  if (name == "if") return IF;
  if (name == "nil") return NIL;
  if (name == "or") return OR;
  if (name == "print") return PRINT;
  if (name == "return") return RETURN;
  if (name == "super") return SUPER;
  if (name == "this") return THIS;
  if (name == "true") return TRUE;
  if (name == "var") return VAR;
  if (name == "while") return WHILE;
  return nil;
}

fun isNameStart(ch) {
  if (ch == nil) {
    return false;
  }
  // '_' or 'a'<=ch<='z' or 'A'<=ch<='Z'
  return ch == 95 or (ch >= 97 and ch <= 122) or (ch >= 65 and ch <= 90);
}

fun isDigit(ch) {
  if (ch == nil) {
    return false;
  }
  // '0'<=ch<='9'
  return ch >= 48 and ch <= 57;
}

class Scanner {
  init() {
    this.line = 1;
    this.ch = getc();
  }

  next() {
    while (this.ch != nil) {
      var ch = this.ch;
      this.ch = getc();
      if (ch == LEFT_PAREN) return Token(LEFT_PAREN, nil, this.line);
      else if (ch == RIGHT_PAREN) return Token(RIGHT_PAREN, nil, this.line);
      else if (ch == LEFT_BRACE) return Token(LEFT_BRACE, nil, this.line);
      else if (ch == RIGHT_BRACE) return Token(RIGHT_BRACE, nil, this.line);
      else if (ch == COMMA) return Token(COMMA, nil, this.line);
      else if (ch == DOT) return Token(DOT, nil, this.line);
      else if (ch == MINUS) return Token(MINUS, nil, this.line);
      else if (ch == PLUS) return Token(PLUS, nil, this.line);
      else if (ch == SEMICOLON) return Token(SEMICOLON, nil, this.line);
      else if (ch == STAR) return Token(STAR, nil, this.line);
      else if (ch == BANG) {
        if (this.ch == EQUAL) {
          this.ch = getc();
          return Token(BANG_EQUAL, nil, this.line);
        }
        return Token(BANG, nil, this.line);
      }
      else if (ch == EQUAL) {
        if (this.ch == EQUAL) {
          this.ch = getc();
          return Token(EQUAL_EQUAL, nil, this.line);
        }
        return Token(EQUAL, nil, this.line);
      }
      else if (ch == LESS) {
        if (this.ch == EQUAL) {
          this.ch = getc();
          return Token(LESS_EQUAL, nil, this.line);
        }
        return Token(LESS, nil, this.line);
      }
      else if (ch == GREATER) {
        if (this.ch == EQUAL) {
          this.ch = getc();
          return Token(GREATER_EQUAL, nil, this.line);
        }
        return Token(GREATER, nil, this.line);
      }
      else if (ch == SLASH) {
        if (this.ch != SLASH) return Token(SLASH, nil, this.line);
        // Comment till end of line
        this.ch = getc();
        while (this.ch != nil and this.ch != 10) {
          this.ch = getc();
        }
        if (this.ch == 10) {
          this.line = this.line + 1;
        }
        this.ch = getc();
      }
      else if (ch == 32 or ch == 9 or ch == 13) {
        // Ignore whitespace: space, tab, and carriage return
      }
      else if (ch == 10) {
        // Newline
        this.line = this.line + 1;  
      }
      else if (ch == 34) {
        // Strings (start and end with double quote)
        var line = this.line;
        var value = "";
        while (this.ch != nil and this.ch != 34) {
          if (this.ch == 10) {
            this.line = this.line + 1;
          }
          value = value + chr(this.ch);
          this.ch = getc();
        }
        if (this.ch == nil) {
          return Token(INVALID, "Unterminated string.", this.line);
        }
        this.ch = getc();
        return Token(STRING, value, line);
      }
      else if (isDigit(ch)) {
        // Numbers ('0' == 48)
        var num = ch - 48;
        while (isDigit(this.ch)) {
          num = num*10 + this.ch - 48;
          this.ch = getc();
        }
        // Fractional part
        if (this.ch == DOT) {
          this.ch = getc();
          if (!isDigit(this.ch)) {
            return Token(INVALID, "Expected digit after .", this.line);
          }
          var numerator = 0;
          var denominator = 1;
          while (isDigit(this.ch)) {
            numerator = numerator*10 + this.ch - 48;
            denominator = denominator*10;
            this.ch = getc();
          }
          num = num + numerator/denominator;
        }
        return Token(NUMBER, num, this.line);
      } else if (isNameStart(ch)) {
        // Identifiers and keywords
        var name = chr(ch);
        while (isNameStart(this.ch) or isDigit(this.ch)) {
          name = name + chr(this.ch);
          this.ch = getc();
        }
        var keyword = keywordType(name);
        if (keyword != nil) {
          return Token(keyword, nil, this.line);
        }
        return Token(IDENTIFIER, name, this.line);
      } else {
        return Token(INVALID, "Unexpected character.", this.line);
      }
    }
    return Token(EOF, nil, this.line);
  }
}

// Test scanner by reading input and displaying tokens
fun testScanner() {
  var scanner = Scanner();
  var done = false;
  while (!done) {
    var token = scanner.next();
    if (token.type == EOF) {
      done = true;
    } else if (token.type == INVALID) {
      done = true;
      print token.value + " on line:";
      print token.line;
    } else {
      if (token.value != nil) {
        print tokenTypeStr(token.type);
        print token.value;
      } else {
        print tokenTypeStr(token.type);
      }
    }
  }
}

// TODO: testScanner();


// List: used in AST for lists of statements. We have to hand-craft
// this as Lox doesn't have a built-in list or array type.

class ListNode {
  init(value) {
    this.value = value;
    this.next = nil;
  }
}

class List {
  init() {
    this.head = nil;
    this.tail = nil;
    this._length = 0;
  }

  append(value) {
    var node = ListNode(value);
    if (this.head == nil) {
      this.head = node;
      this.tail = node;
    } else {
      this.tail.next = node;
      this.tail = node;
    }
    this._length = this._length + 1;
    return this;
  }

  foreach(f) {
    var node = this.head;
    while (node != nil) {
      if (f(node.value)) {
        return;
      }
      node = node.next;
    }
  }

  get(n) {
    var node = this.head;
    var i = 0;
    while (node != nil) {
      if (i == n) {
        return node.value;
      }
      node = node.next;
      i = i + 1;
    }
    return nil;
  }

  length() {
    return this._length;
  }
}


// Environment: used in interpreter to store and resolve variables.

class EnvironmentItem {
  init(name, value) {
    this.name = name;
    this.value = value;
  }
}

class Environment {
  init(enclosing) {
    this.enclosing = enclosing;
    this.items = List();
  }

  find(name) {
    var found;
    fun findItem(item) {
      if (item.name == name) {
        found = item;
        // Exit foreach loop early after finding it
        return true;
      }
      return false;
    }
    this.items.foreach(findItem);
    return found;
  }

  get(name) {
    var item = this.find(name);
    if (item != nil) {
      return item.value;
    }
    if (this.enclosing != nil) {
      return this.enclosing.get(name);
    }
    runtimeError("Undefined variable '" + name + "'.");
  }

  assign(name, value) {
    var item = this.find(name);
    if (item != nil) {
      item.value = value;
      return;
    }
    if (this.enclosing != nil) {
      this.enclosing.assign(name, value);
      return;
    }
    runtimeError("Undefined variable '" + name + "'.");
  }

  define(name, value) {
    var item = this.find(name);
    if (item == nil) {
      this.items.append(EnvironmentItem(name, value));
    } else {
      // Redefining a variable just sets it;
      item.value = value;
    }
  }

  // TODO
  // ancestor(distance) {
  //   var environment = this;
  //   for (var i = 0; i < distance; i = i + 1) {
  //     environment = environment.enclosing;
  //   }
  //   return environment;
  // }

  // getAt(distance, name) {
  //   return this.ancestor(distance).find(name).value;
  // }

  // assignAt(distance, name, value) {
  //   this.ancestor(distance).find(name).value = value;
  // }
}


// Syntax tree nodes

// Expressions

class Assign {
  init(name, value) {
    this.type = "Assign";
    this.name = name;
    this.value = value;
  }

  str() {
    return this.name + " = " + this.value.str();
  }

  evaluate(interpreter) {
    var value = this.value.evaluate(interpreter);
    interpreter.environment.assign(this.name, value);
    return value;
    // TODO

    var distance = interpreter.locals.get(this);
    if (distance != nil) {
      interpreter.environment.assignAt(distance, this.name, value);
    } else {
      interpreter.globals.assign(this.name, value);
    }
    return value;
  }
}

class Binary {
  init(left, operator, right) {
    this.type = "Binary";
    this.left = left;
    this.operator = operator;
    this.right = right;
  }

  str() {
    return "(" + this.left.str() + " " + tokenTypeStr(this.operator) +
           " " + this.right.str() + ")";
  }

  evaluate(interpreter) {
    var left = this.left.evaluate(interpreter);
    var right = this.right.evaluate(interpreter);
    if (this.operator == PLUS) return left + right;
    if (this.operator == MINUS) return left - right;
    if (this.operator == STAR) return left * right;
    if (this.operator == SLASH) return left / right;
    if (this.operator == BANG_EQUAL) return left != right;
    if (this.operator == EQUAL_EQUAL) return left == right;
    if (this.operator == GREATER) return left > right;
    if (this.operator == GREATER_EQUAL) return left >= right;
    if (this.operator == LESS) return left < right;
    if (this.operator == LESS_EQUAL) return left <= right;
    return nil; // Unreachable
  }
}

class LoxFunction {
  init(declaration, closure, isInitializer) {
    this.declaration = declaration;
    this.closure = closure;
    this.isInitializer = isInitializer;
  }

  bind(instance) {
    var environment = Environment(this.closure);
    environment.define("this", instance);
    return LoxFunction(this.declaration, environment, this.isInitializer);
  }

  arity() {
    return this.declaration.params.length();
  }

  call(interpreter, arguments) {
    var environment = Environment(this.closure);
    var i = 0;
    fun defineArg(name) {
      environment.define(name, arguments.get(i));
      i = i + 1;
    }
    this.declaration.params.foreach(defineArg);

    var ret = interpreter.executeBlock(this.declaration.body, environment);
    if (this.isInitializer) {
      return this.closure.get("this");
    }
    if (ret) {
      return ret.value;
    }
    return nil;
  }
}

class Call {
  init(callee, arguments) {
    this.type = "Call";
    this.callee = callee;
    this.arguments = arguments;
  }

  str() {
    var s = this.callee.str() + "(";
    var addComma = false;
    fun addArgument(argument) {
      if (addComma) {
        s = s + ", ";
      }
      addComma = true;
      s = s + argument.str();
    }
    this.arguments.foreach(addArgument);
    s = s + ")";
    return s;
  }

  evaluate(interpreter) {
    var callee = this.callee.evaluate(interpreter);
    var arguments = List();
    fun addArgument(argument) {
      arguments.append(argument.evaluate(interpreter));
    }
    this.arguments.foreach(addArgument);
    if (arguments.length() != callee.arity()) {
      runtimeError("Expected " + numberStr(callee.arity()) +
                   " arguments but got " + numberStr(arguments.length()) + ".");
    }
    return callee.call(interpreter, arguments);
  }
}

class Get {
  init(object, name) {
    this.type = "Get";
    this.object = object;
    this.name = name;
  }
  
  str() {
    return this.object.str() + "." + this.name;
  }

  evaluate(interpreter) {
    TODO_Get;
  }
}

class Grouping {
  init(expr) {
    this.type = "Grouping";
    this.expr = expr;
  }

  str() {
    return "(" + this.expr.str() + ")";
  }

  evaluate(interpreter) {
    return this.expr.evaluate(interpreter);
  }
}

fun numberStr(num) {
  // TODO: only handles integers right now
  var s = "";
  if (num < 0) {
    s = "-";
    num = -num;
  }
  var mult = 1;
  while (mult*10 <= num) {
    mult = mult * 10;
  }
  while (mult >= 1) {
    var digit = 0;
    while (mult*(digit+1) <= num) {
      digit = digit + 1;
    }
    s = s + chr(digit + 48);
    num = num - mult*digit;
    mult = mult / 10;
  }
  return s;
}

class Literal {
  init(kind, value) {
    this.type = "Literal";
    this.kind = kind;
    this.value = value;
  }

  str() {
    if (this.kind == "boolean") {
      if (this.value) {
        return "true";
      } else {
        return "false";
      }
    }
    if (this.kind == "nil") {
      return "nil";
    }
    if (this.kind == "number") {
      return numberStr(this.value);
    }
    if (this.kind == "string") {
      return chr(34) + this.value + chr(34);
    }
    return "<unexpected kind>";
  }

  evaluate(interpreter) {
    return this.value;
  }
}

class Logical {
  init(left, operator, right) {
    this.type = "Logical";
    this.left = left;
    this.operator = operator;
    this.right = right;
  }

  str() {
    return "(" + this.left.str() + " " + tokenTypeStr(this.operator) +
           " " + this.right.str() + ")";
  }

  evaluate(interpreter) {
    var left = this.left.evaluate(interpreter);
    if (this.operator == AND) {
      return left and this.right.evaluate(interpreter);
    } else {
      return left or this.right.evaluate(interpreter);
    }
  }
}

class Set {
  init(object, name, value) {
    this.type = "Set";
    this.object = object;
    this.name = name;
    this.value = value;
  }

  str() {
    return this.object.str() + "." + this.name + " = " + this.value.str();
  }

  evaluate(interpreter) {
    TODO_Set;
  }
}

class Super {
  init(method) {
    this.type = "Super";
    this.method = method;
  }

  str() {
    return "super." + this.method;
  }

  evaluate(interpreter) {
    TODO_Super;
  }
}

class This {
  init() {
    this.type = "This";
  }

  str() {
    return "this";
  }

  evaluate(interpreter) {
    TODO_This;
  }
}

class Unary {
  init(operator, right) {
    this.type = "Unary";
    this.operator = operator;
    this.right = right;
  }

  str() {
    return tokenTypeStr(this.operator) + this.right.str();
  }

  evaluate(interpreter) {
    var right = this.right.evaluate(interpreter);
    if (this.operator == BANG) return !right;
    return -right;
  }
}

class Variable {
  init(name) {
    this.type = "Variable";
    this.name = name;
  }

  str() {
    return this.name;
  }

  evaluate(interpreter) {
    return interpreter.environment.get(this.name);
  }
}

// Statements

class Program {
  init(statements) {
    this.type = "Program";
    this.statements = statements;
  }

  str() {
    var s = "";
    fun format(statement) {
      s = s + statement.str();
    }
    this.statements.foreach(format);
    return s;
  }

  execute(interpreter) {
    fun executeStatement(statement) {
      statement.execute(interpreter);
    }
    this.statements.foreach(executeStatement);
  }
}

var indent = 0;

class Block {
  init(statements) {
    this.type = "Block";
    this.statements = statements;
  }

  str() {
    var s = "{" + chr(10);
    indent = indent + 1;
    fun format(statement) {
      for (var i = 0; i < indent; i = i + 1) {
        s = s + "  ";
      }
      s = s + statement.str();
    }
    this.statements.foreach(format);
    indent = indent - 1;
    for (var i = 0; i < indent; i = i + 1) {
      s = s + "  ";
    }
    s = s + "}" + chr(10);
    return s;
  }

  execute(interpreter) {
    return interpreter.executeBlock(this.statements, Environment(interpreter.environment));
  }
}

class Class {
  init(name, superclass, methods) {
    this.type = "Class";
    this.name = name;
    this.superclass = superclass;
    this.methods = methods;
  }

  str() {
    var s = "class " + this.name + " ";
    if (this.superclass != nil) {
      s = s + "< " + this.superclass.name + " ";
    }
    s = s + Block(this.methods).str(); // Reuse Block.str()
    return s;
  }

  execute(interpreter) {
    TODO_Class;
  }
}

class Expression {
  init(expression) {
    this.type = "Expression";
    this.expression = expression;
  }

  str() {
    return this.expression.str() + ";" + chr(10);
  }

  execute(interpreter) {
    this.expression.evaluate(interpreter);
  }
}

class Function {
  init(name, params, body) {
    this.type = "Function";
    this.name = name;
    this.params = params;
    this.body = body;
  }

  str() {
    var s = "fun " + this.name + "(";
    var addComma = false;
    fun addParam(param) {
      if (addComma) {
        s = s + ", ";
      }
      addComma = true;
      s = s + param;
    }
    this.params.foreach(addParam);
    s = s + ") ";
    s = s + Block(this.body).str();
    return s;
  }

  execute(interpreter) {
    var function = LoxFunction(this, interpreter.environment, false);
    interpreter.environment.define(this.name, function);
  }
}

class If {
  init(condition, thenBranch, elseBranch) {
    this.type = "If";
    this.condition = condition;
    this.thenBranch = thenBranch;
    this.elseBranch = elseBranch;
  }

  str() {
    var s = "if (" + this.condition.str() + ") " + this.thenBranch.str();
    if (this.elseBranch != nil) {
      for (var i = 0; i < indent; i = i + 1) {
        s = s + "  ";
      }
      s = s + "else " + this.elseBranch.str();
    }
    return s;
  }

  execute(interpreter) {
    if (this.condition.evaluate(interpreter)) {
      return this.thenBranch.execute(interpreter);
    } else if (this.elseBranch != nil) {
      return this.elseBranch.execute(interpreter);
    }
  }
}

class Print {
  init(expression) {
    this.type = "Print";
    this.expression = expression;
  }

  str() {
    return "print " + this.expression.str() + ";" + chr(10);
  }

  execute(interpreter) {
    print this.expression.evaluate(interpreter);
  }
}

class ReturnValue {
  init(value) {
    this.value = value;
  }
}

class Return {
  init(value) {
    this.type = "Return";
    this.value = value;
  }

  str() {
    return "return " + this.value.str() + ";" + chr(10);
  }

  execute(interpreter) {
    var value;
    if (this.value != nil) {
      value = this.value.evaluate(interpreter);
    }
    return ReturnValue(value);
  }
}

class Var {
  init(name, initializer) {
    this.type = "Var";
    this.name = name;
    this.initializer = initializer;
  }

  str() {
    var s = "var " + this.name;
    if (this.initializer != nil) {
      s = s + " = " + this.initializer.str();
    }
    s = s + ";" + chr(10);
    return s;
  }

  execute(interpreter) {
    var value;
    if (this.initializer != nil) {
      value = this.initializer.evaluate(interpreter);
    }
    interpreter.environment.define(this.name, value);
  }
}

class While {
  init(condition, body) {
    this.type = "While";
    this.condition = condition;
    this.body = body;
  }

  str() {
    return "while (" + this.condition.str() + ") " + this.body.str();
  }

  execute(interpreter) {
    while (this.condition.evaluate(interpreter)) {
      var ret = this.body.execute(interpreter);
      if (ret) {
        return ret;
      }
    }
  }
}

// The parser

class Parser {
  init() {
    this.functionDepth = 0;
    this.token = nil;
    this.scanner = Scanner();
    this.next();
  }

  next() {
    this.previous = this.token;
    this.token = this.scanner.next();
    if (this.token.type == INVALID) {
      this.error(this.token, this.token.value);
    }
  }

  error(token, message) {
    var at;
    if (token.type == INVALID) {
      at = "Error: ";
    } else if (token.type == IDENTIFIER) {
      at = "Error at '" + token.value + "': ";
    } else if (token.type == NUMBER) {
      at = "Error at '" + numberStr(token.value) + "': ";
    } else {
      at = "Error at '" + tokenTypeStr(token.type) + "': ";
    }
    print_error("[line " + numberStr(this.token.line) + "] " + at + message);
    exit(65);
  }

  match(type) {
    if (this.token.type == type) {
      var previous = this.token;
      this.next();
      return previous;
    }
    return nil;
  }

  consume(type, message) {
    var token = this.token;
    if (this.match(type)) {
      return token;
    }
    this.error(this.token, message);
  }

  parse() {
    var statements = List();
    while (this.token.type != EOF) {
      statements.append(this.declaration());
    }
    return Program(statements);
  }

  expression() {
    return this.assignment();
  }

  declaration() {
    if (this.match(CLASS)) return this.classDeclaration();
    if (this.match(FUN)) return this.function("function");
    if (this.match(VAR)) return this.varDeclaration();
    return this.statement();
  }

  classDeclaration() {
    var name = this.consume(IDENTIFIER, "Expect class name.");
    var superclass;
    if (this.match(LESS)) {
      var superName = this.consume(IDENTIFIER, "Expect superclass name.");
      superclass = Variable(superName.value);
    }

    this.consume(LEFT_BRACE, "Expect '{' before class body.");
    var methods = List();
    while (this.token.type != EOF and this.token.type != RIGHT_BRACE) {
      methods.append(this.function("method"));
    }
    this.consume(RIGHT_BRACE, "Expect '}' after class body.");

    return Class(name.value, superclass, methods);
  }

  statement() {
    if (this.match(FOR)) return this.forStatement();
    if (this.match(IF)) return this.ifStatement();
    if (this.match(PRINT)) return this.printStatement();
    if (this.match(RETURN)) return this.returnStatement();
    if (this.match(WHILE)) return this.whileStatement();
    if (this.match(LEFT_BRACE)) return Block(this.block());
    return this.expressionStatement();
  }

  forStatement() {
    this.consume(LEFT_PAREN, "Expect '(' after 'for'.");

    var initializer;
    if (this.match(SEMICOLON)) {
      // No initializer
    } else if (this.match(VAR)) {
      initializer = this.varDeclaration();
    } else {
      initializer = this.expressionStatement();
    }

    var condition;
    if (this.token.type != SEMICOLON) {
      condition = this.expression();
    }
    this.consume(SEMICOLON, "Expect ';' after loop condition.");

    var increment;
    if (this.token.type != RIGHT_PAREN) {
      increment = Expression(this.expression());
    }
    this.consume(RIGHT_PAREN, "Expect ')' after for clauses.");

    var body = this.statement();

    // Desugar increment
    if (increment != nil) {
      var statements = List();
      statements.append(body);
      statements.append(increment);
      body = Block(statements);
    }

    // Desugar condition
    if (condition == nil) {
      condition = Literal("boolean", true);
    }
    body = While(condition, body);

    // Desugar initializer
    if (initializer != nil) {
      var statements = List();
      statements.append(initializer);
      statements.append(body);
      body = Block(statements);
    }

    return body;
  }

  ifStatement() {
    this.consume(LEFT_PAREN, "Expect '(' after 'if'.");
    var condition = this.expression();
    this.consume(RIGHT_PAREN, "Expect ')' after if condition.");
    var thenBranch = this.statement();
    var elseBranch;
    if (this.match(ELSE)) {
      elseBranch = this.statement();
    }
    return If(condition, thenBranch, elseBranch);
  }

  printStatement() {
    var value = this.expression();
    this.consume(SEMICOLON, "Expect ';' after value.");
    return Print(value);
  }

  returnStatement() {
    if (this.functionDepth <= 0) {
      this.error(this.previous, "Cannot return from top-level code.");
    }
    var value;
    if (this.token.type != SEMICOLON) {
      value = this.expression();
    }
    this.consume(SEMICOLON, "Expect ';' after return value.");
    return Return(value);
  }

  varDeclaration() {
    var name = this.consume(IDENTIFIER, "Expect variable name.");
    var initializer;
    if (this.match(EQUAL)) {
      initializer = this.expression();
    }
    this.consume(SEMICOLON, "Expect ';' after variable declaration.");
    return Var(name.value, initializer);
  }

  whileStatement() {
    this.consume(LEFT_PAREN, "Expect '(' after 'while'.");
    var condition = this.expression();
    this.consume(RIGHT_PAREN, "Expect ')' after condition.");
    var body = this.statement();
    return While(condition, body);
  }

  expressionStatement() {
    var expr = this.expression();
    this.consume(SEMICOLON, "Expect ';' after expression.");
    return Expression(expr);
  }

  function(kind) {
    var name = this.consume(IDENTIFIER, "Expect " + kind + " name.");
    this.consume(LEFT_PAREN, "Expect '(' after " + kind + " name.");
    var parameters = List();
    var n = 0;
    while (this.token.type != RIGHT_PAREN) {
      if (n > 0) {
        this.consume(COMMA, "Expect ')' after parameters.");
      }
      if (n >= 8) {
        this.error(this.token, "Cannot have more than 8 parameters.");
      }
      var paramName = this.consume(IDENTIFIER, "Expect parameter name.");

      // Ensure we don't have duplicate param names (Lox does this in Resolver)
      fun checkDupe(name) {
        if (name == paramName.value) {
          this.error(paramName, "Variable with this name already declared in this scope.");
        }
      }
      parameters.foreach(checkDupe);

      parameters.append(paramName.value);
      n = n + 1;
    }
    this.consume(RIGHT_PAREN, "Expect ')' after parameters.");
    this.consume(LEFT_BRACE, "Expect '{' before " + kind + " body.");
    this.functionDepth = this.functionDepth + 1;
    var body = this.block();
    this.functionDepth = this.functionDepth - 1;
    return Function(name.value, parameters, body);
  }

  block() {
    var statements = List();
    while (this.token.type != EOF and this.token.type != RIGHT_BRACE) {
      statements.append(this.declaration());
    }
    this.consume(RIGHT_BRACE, "Expect '}' after block.");
    return statements;
  }

  assignment() {
    var expr = this.or_();
    if (this.match(EQUAL)) {
      var equals = this.previous;
      var value = this.assignment();
      if (expr.type == "Variable") {
        return Assign(expr.name, value);
      }
      if (expr.type == "Get") {
        return Set(expr.object, expr.name, value);
      }
      this.error(equals, "Invalid assignment target.");
    }
    return expr;
  }

  or_() {
    var expr = this.and_();
    while (this.match(OR)) {
      var right = this.and_();
      expr = Logical(expr, OR, right);
    }
    return expr;
  }

  and_() {
    var expr = this.equality();
    while (this.match(AND)) {
      var right = this.equality();
      expr = Logical(expr, AND, right);
    }
    return expr;
  }

  equality() {
    var expr = this.comparison();
    while (this.token.type == BANG_EQUAL or this.token.type == EQUAL_EQUAL) {
      var operator = this.token.type;
      this.next();
      var right = this.comparison();
      expr = Binary(expr, operator, right);
    }
    return expr;
  }

  comparison() {
    var expr = this.addition();
    while (this.token.type == GREATER or this.token.type == GREATER_EQUAL or
           this.token.type == LESS or this.token.type == LESS_EQUAL) {
      var operator = this.token.type;
      this.next();
      var right = this.addition();
      expr = Binary(expr, operator, right);
    }
    return expr;
  }

  addition() {
    var expr = this.multiplication();
    while (this.token.type == MINUS or this.token.type == PLUS) {
      var operator = this.token.type;
      this.next();
      var right = this.multiplication();
      expr = Binary(expr, operator, right);
    }
    return expr;
  }

  multiplication() {
    var expr = this.unary();
    while (this.token.type == SLASH or this.token.type == STAR) {
      var operator = this.token.type;
      this.next();
      var right = this.unary();
      expr = Binary(expr, operator, right);
    }
    return expr;
  }

  unary() {
    if (this.token.type == BANG or this.token.type == MINUS) {
      var operator = this.token.type;
      this.next();
      var right = this.unary();
      return Unary(operator, right);
    }
    return this.call();
  }

  call() {
    var expr = this.primary();
    var loop = true;
    while (loop) {
      if (this.match(LEFT_PAREN)) {
        var arguments = List();
        var n = 0;
        while (this.token.type != RIGHT_PAREN) {
          if (n > 0) {
            this.consume(COMMA, "Expect ')' after arguments.");
          }
          if (n >= 8) {
            this.error(this.token, "Cannot have more than 8 arguments.");
          }
          arguments.append(this.expression());
          n = n + 1;
        }
        this.consume(RIGHT_PAREN, "Expect ')' after arguments.");
        expr = Call(expr, arguments);
      } else if (this.match(DOT)) {
        var name = this.consume(IDENTIFIER, "Expect property name after '.'.");
        expr = Get(expr, name.value);
      } else {
        loop = false;
      }
    }
    return expr;
  }

  primary() {
    if (this.match(FALSE)) return Literal("boolean", false);
    if (this.match(TRUE)) return Literal("boolean", true);
    if (this.match(NIL)) return Literal("nil", nil);
    var number = this.match(NUMBER);
    if (number) {
      return Literal("number", number.value);
    }
    var string = this.match(STRING);
    if (string) {
      return Literal("string", string.value);
    }
    if (this.match(SUPER)) {
      this.consume(DOT, "Expect '.' after 'super'.");
      var method = this.consume(IDENTIFIER, "Expect superclass method name.");
      return Super(method.value);
    }
    if (this.match(THIS)) {
      return This();
    }
    var identifier = this.match(IDENTIFIER);
    if (identifier) {
      return Variable(identifier.value);
    }
    if (this.match(LEFT_PAREN)) {
      var expr = this.expression();
      this.consume(RIGHT_PAREN, "Expect ')' after expression.");
      return Grouping(expr);
    }
    this.error(this.token, "Expect expression.");
  }
}


// The interpreter

class Builtin0 {
  init(f) {
    this.f = f;
  }

  arity() {
    return 0;
  }

  call(interpreter, arguments) {
    return this.f();
  }
}

class Builtin1 {
  init(f) {
    this.f = f;
  }

  arity() {
    return 1;
  }

  call(interpreter, arguments) {
    return this.f(arguments.get(0));
  }
}

class Interpreter {
  init(program) {
    this.program = program;
    this.globals = Environment(nil);
    this.environment = this.globals;

    // Define built-in functions
    this.globals.define("clock", Builtin0(clock));
    this.globals.define("getc", Builtin0(getc));
    this.globals.define("chr", Builtin1(chr));
    this.globals.define("exit", Builtin1(exit));
  }

  interpret() {
    this.program.execute(this);
  }

  executeBlock(statements, environment) {
    var previous = this.environment;
    this.environment = environment;
    var ret;
    fun executeStatement(statement) {
      ret = statement.execute(this);
      if (ret) {
        // Stop early if there was "return" statement
        return true;
      }
      return false;
    }
    statements.foreach(executeStatement);
    this.environment = previous;
    return ret;
  }

  // lookupVariable(name, expr) {
  //   return this.globals.get(name);
  //   // TODO
  //   var distance = this.locals.get(expr);
  //   if (distance != nil) {
  //     return this.environment.getAt(distance, name);
  //   } else {
  //     return this.globals.get(name);
  //   }
  // }
}

fun runtimeError(message) {
  print_error(message);
  print_error("[line 1]"); // TODO: this is hack (it's not always line 1)
  exit(70);
}

var parser = Parser();
var program = parser.parse();

// DEBUG: uncomment these two lines to pretty-print the parsed syntax tree
// print program.str();
// print "-----";

var interpreter = Interpreter(program);
interpreter.interpret();
